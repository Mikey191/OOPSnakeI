#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <Windows.h>
#include <cstring> // (3) модуль работы со строками
using namespace std;

// (1) функция которая переводит курсор в заданное положение
void MoveXY(int x, int y)
{
	COORD pos;
	pos.X = x;
	pos.Y = y;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
	//	SetConsoleCursorPosition - устанавливает положение курсора в положение
	//заданное параметром pos.
	//	GetStdHandle - возвращает указатель на стандартное устройство вводов выводов
	//	STD_OUTPUT_HANDLE - означает что мы хотим получить указатель на устройство вывода
	//связанное с консольным окном
}

// (2) структура для работы с картой
#define mWidth 80 //mWidth и mHeight - размер консольного окна в символах
#define mHeight 25
struct TMap
{
	char map1[mHeight][mWidth + 1];
	//	map1 - двумерный массив символов которые будут выводится в наше консоль
	//это и есть вся наша карта
	//mHeight в массиве - ось Y
	//mWidth + 1 в массиве - ось Х. 
	//+1 сдесь нужен так как в конце строки будет символ конца строки
	void Clear();
	void Show();
};
// (4) метод Clear
void TMap::Clear()
{
	for (int i = 0; i < mWidth; i++)//заполняем 0-ю строку пробелами
	{
		map1[0][i] = ' ';
	}
	map1[0][mWidth] = '\0';//в конце строки знак конец строки
	for (int j = 1; j < mHeight; j++)
	{
		strncpy(map1[j], map1[0], mWidth + 1);//копирую нулевую строку во все остальные строки
	}
	//* - это яблоки которые должна съесть змейка, что бы вырости
	map1[12][20] = '*';
	map1[12][60] = '*';
	map1[5][40] = '*';
	map1[20][40] = '*';
}
// (5) процедура Show
void TMap::Show()
{
	MoveXY(0, 0);//перемещаем курсор в левый верхний угол
	map1[mHeight - 1][mWidth - 1] = '\0';//устанавливаем последний символ последней строки символ конца строки
	for (int j = 0; j < mHeight; j++)
	{
		cout << map1[j];//будет показывать всю нашу карту
	}
}

// (7) создаем класс для работы со змейкой
enum TDirection{dirLeft, dirRight, dirUp, dirDown};//перечислимый тип который описывает траекторию движения
//(11) для управления змейкой добавляем еще один метов в класс змейки class TSnake
enum TResult {reOk, reKill};//(11) TResult - это тип результата для функции управления змейкой. reKill - змейка погибла. Это значение будет возвращено в случае гибели змейки
//(14) создаем хвост
#define sLen 1000

class TSnake
{
	int x, y;//положение головы змейки
	TMap* mp;//mp - карта на которой мы будем рисовать нашу змейку
	TDirection dir;//dir - текущее направление движения змейки
	POINT tail[sLen];//(14) sLen - максимальная длина хвоста. tail - массив с координатами каждого элемента хвоста
	int len;//(14) len - текущая длина хвоста (те размер массива tail)
public:
	void AddTail(int _x, int _y);//(14)AddTail - добавляет один элемент к хвосту змейки
	void MoveTail(int _x, int _y);//(14)MoveTail - будет передвигать хвост змейки
	//(18) добавим метод, который будет добавлять сразу несколько элементов хвоста
	void AddTailCnt(int _x, int _y, int cnt);
	TSnake(TMap* _mp);//конструктор для рисования змейки
	void Init(int _x, int _y, TDirection _dir);//метод Init. он устанавливает начальное положение змейки
	void PutOnMap();//метод PutOnMap помещает змейку на карту
	//(11) UserControl - это метод управления движения змейки
	TResult UserControl(char w, char s, char a, char d);//(11)на вход мы передаем входы клавишь которыми игрок управляет змейкой
};

//(18) реализация метода AddTailCnt
void TSnake::AddTailCnt(int _x, int _y, int cnt)//cnt - это количество элементов хвоста которые нужно добавить
{
	for (int i = 0; i < cnt; i++)//вызываем метод добавления элемента нужное кол-во раз (cnt)
	{
		AddTail(_x, _y);
	}
}

//(15) напишем реализацию методов AddTail и MoveTail
void TSnake::MoveTail(int _x, int _y) //x и у - это позиции в которые должен передвинутся хвост
{
	for (int i = len-1; i >= 0; i--)
	{
		tail[i + 1] = tail[i];//сначало нужно передвинуть все элементы хвоста на один элемент назад
	}
	tail[0].x = _x;//Нулевому элементу присвоить значение координат (те голова отползла от хвоста и в образовавшеся место мы добавляем новый элемент)
	tail[0].y = _y;
}

void TSnake::AddTail(int _x, int _y)//добавление элемента 
{
	MoveTail(_x, _y);//тут происходит все тоже самое
	len++;//только длина хвоста увеличивается
	if (len >= sLen) len = sLen - 1;
}

//(12) Реализация метода управления
TResult TSnake::UserControl(char w, char s, char a, char d)
{
	//(17) в методе UserControl добавляем движение хвоста
	POINT old;
	old.x = x;
	old.y = y;

	//(12) в зависимости от нажатой клавиши мы задаем направление
	if (GetKeyState(w) < 0) dir = dirUp;
	if (GetKeyState(s) < 0) dir = dirDown;
	if (GetKeyState(a) < 0) dir = dirLeft;
	if (GetKeyState(d) < 0) dir = dirRight;
	//(12) в зависимости от направления мы меняем координаты головы змейки
	if (dir == dirLeft) x--;
	if (dir == dirRight) x++;
	if (dir == dirUp) y--;
	if (dir == dirDown) y++;
	//(12) если змейка вышла за пределы экрана значит игрок проигрывает
	if ((x < 0) || (x >= mWidth) ||
		(y < 0) || (y >= mHeight)
		//(20) прописываем логику удара о хвост/если змейка дотронулась хвоста будет считаться погибшей
		|| (mp->map1[y][x] == '+')) 
		return reKill;

	//(18) Добавляем возможность собирать яблоки
	if (mp->map1[y][x] == '*')
	{
		//AddTail(old.x, old.y);
		//(19)вызывам функцию AddTailCnt в методе UserControl вместо AddTail
		AddTailCnt(old.x, old.y, 5);//за каждое съеденное яблоко змейка будет расти на 5 элементов
	}
	else
	{
		MoveTail(old.x, old.y);//(17) old - это позиция головы до перемещения, 
							//именно в эту позицию мы будем добавлять элемент при движении змейки
	}


	return reOk;
}

	// (8) распишим оба метода и конструктор из клааса TSnake
void TSnake::Init(int _x, int _y, TDirection _dir)//передаем начальное положение и направление
{
	x = _x;
	y = _y;
	dir = _dir;
	//(16) Задаем начальную длину хвоста в Init
	len = 0;
}
void TSnake::PutOnMap()//помещение змейки на карту
{
	mp->map1[y][x] = '@';//символ @ на ее координатах - голова змеи
	//(16) при рисовании змейки надо учесть хвост
	for (int i = 0; i < len; i++)//(16) проходимся по всем элементам хвоста
	{
		mp->map1[tail[i].y][tail[i].x] = '+';//(16)рисуем в них +
	}
}
TSnake::TSnake(TMap* _mp)//конструктор TSnake
{
	mp = _mp; //устанавливаем карту на которой будем рисовать змейку
	Init(0, 0, dirRight);//проводим базавую инициализацию
}

int main()
{
	//(21) добавим возможность играть вдвоем
	//int userCnt = 2;

	// (6) создаем объект и цикл для показа всей нашей карты
	TMap map1;//создание объекта
	// (9) создание змейки на карте
	TSnake snake1(&map1);//в конструктор мы передаем указатель на карту (9)
	//(21) проинициализурем вторую змейку
	/*TSnake snake2(&map1);
	snake1.Init(10, 5, dirRight);*/

	snake1.Init(70, 5, dirLeft);//задаем начальное положение и направление змейки (9)
	//(16.1)для проверки добавления хвоста
	//(19.1) убираем тестовый код
	/*snake1.AddTail(3, 3);
	snake1.AddTail(3, 4);
	snake1.AddTail(3, 5);*/

	do//(6)
	{
		//(13)вызываем UserControl в нашем основном цикле
		if (snake1.UserControl('W', 'S', 'A', 'D') == reKill)
			snake1.Init(10, 5, dirRight);//(13)
		map1.Clear();//в цикле сначало очищаем поле(6)
		//(10) отобразим змейку на карте (это нужно сделать после очистки карты)
		snake1.PutOnMap();//(10)
		map1.Show();//выводим на экран все строки карты(6)
		Sleep(80);//ждем 80 милисекунд(6)

	} while (GetKeyState(VK_ESCAPE) >= 0);//выход из цикла делаем по кнопки esc(6)

	return 0;
}